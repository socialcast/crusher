#!/usr/bin/env ruby
$LOAD_PATH.unshift File.join( File.dirname(__FILE__) + "/../lib" )
require 'crusher'
require 'eventmachine'
require 'activesupport'

config = Crusher::Configurator::Configuration.new('Crushfile')

target_name = ARGV[0].to_sym
scenario_name = ARGV[1].to_sym

@target = config.targets[target_name]
@scenario = config.scenarios[scenario_name]



puts "Fatal Error: Unknown target '#{target_name}'" unless @target
puts "Fatal Error: Unknown scenario '#{scenario_name}'" unless @scenario 
exit(1) unless @target && @scenario

puts @scenario.phases.inspect


SPIN_UP_PER_JOB = 0.3
@total_launch_jobs = @scenario.launch_jobs.inject(0) {|memo, job| memo + job[:count]}
@spin_up_time = (SPIN_UP_PER_JOB * @total_launch_jobs).to_i

@options = {}
@options[:post_spinup_margin] = 0
@options[:start_time] = Time.now + @spin_up_time + @options[:post_spinup_margin]
@options[:start_up_jitter] = 10
@options[:end_time] = @options[:start_time] + @scenario.duration
@options[:log_file] = ARGV[2]



puts "Allocating #{@spin_up_time} to spin up #{@total_launch_jobs} jobs, and #{@options[:post_spinup_margin]} for server to cool"
puts "Test will begin around #{@options[:start_time]}"

@queued_jobs = []

def queue_job(job, id)
  @queued_jobs <<  [job, id]
  # launch_queued_jobs if @queued_jobs.length >= 50
end

def run_next_phase
  return if @scenario.phases.length == 0
  
  next_phase = @scenario.phases.shift
  
  if next_phase[:wait]
    EM::Timer.new(next_phase[:wait].to_i) do
      run_next_phase
    end
  elsif next_phase[:over]
    seconds_per_job = next_phase[:over].to_f / @running_jobs.count.to_f
    next_job = 0
    
    slow_iterator = EM::PeriodicTimer.new(seconds_per_job) do
      next_phase[:proc].call(@running_jobs[next_job])
      next_job += 1
      
      if next_job >= @running_jobs.length
        slow_iterator.cancel
        run_next_phase
      end
    end
  end
  
end


def launch_queued_jobs
  return nil if @queued_jobs.length == 0
    
  fork do
    
    
    @running_jobs = []
    
    # Reseed the pseudorandom number generator with the process's PID file,
    # as we assume this code will be run in a forked process.
    Kernel.srand(Process.pid)
    
    EM.run do
      @queued_jobs.each do |settings|
        job, job_id = settings
        options = @options.merge(:process_name => "#{job[:type]} #{job_id}")
        @running_jobs << job[:proc].call(@target, @scenario, options, job_id)
      end
      
      run_next_phase
      
    end
    
  end
  
  @queued_jobs = []
  
  nil
end

@scenario.launch_jobs.each do |job|
  job_id = 0
  puts job.keys.inspect
  puts "Launching #{job[:count]} #{job[:type]}(s)..."
  job[:count].times do
    queue_job(job, job_id)
    job_id += 1
  end
end

launch_queued_jobs
